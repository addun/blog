---
id: fTWq6d
oldId: 1963
title: State management in TypeScript
description: |
  You can find plenty of examples showing how state management libraries work,
  few people focus on it why do we need state management and what problems does it cause (solve?).

  In this article I will walk you through, step by step,
  what common application state issues might look like
  applications and how to deal with them regardless
  of whether you use because it doesn't matter what you use, only for what purpose.
tags:
  - angular
  - angular-17
  - typescript
thumbnail: "./thumbnail.png"
date: "2023-12-05"
modified: "2024-01-07"
repository: "state-management"
---

import { Note } from "@components/Note";
import { Demo } from "@components/Demo";

## Loading state

Imagine a situation where you have to send a request to a server to get data.
This operation can take some time so it can be a good idea
to display a spinner with some text to inform a user that
something is happening (instead of displaying a blank page).
To do this we can create a variable `loading` and write in our
template logic to display one of two views: _loading view_ or _data view_.

<Demo height={400} repository={frontmatter.repository} path="loading-state" branch="main" />

```ts
export class ExampleComponent {
  private toDos$ = inject(TodoService).getToDos({ limit: 3 });

  loading = true;
  toDos: ToDo[] = [];

  constructor() {
    this.toDos$.subscribe((toDos) => {
      this.toDos = toDos;
      this.loading = false;
    });
  }
}
```

```jsx
if (loading) {
  <p>Spinner</p>;
} else {
  <table> ... </table>;
}
```

## More states

In a real scenario, we have more than just two states.
When we display some data we want to allow users to filter, sort or paginate it.
In this case, it would be nice to display some kind of spinner when data are updating.
But what about errors? A server can also respond with a temporary issue
(no connection to the database, internal server error, or timeout).
It also would be nice to display.

Similar to before, we can do this by adding new variables to our view: `error` and `refreshing`.
But this does not cover all needs.
We also want to store data about the error and also items to display.
This makes our component bigger and less readable.

<Demo height={450} repository={frontmatter.repository} path="more-states" branch="main" />

```ts
export class DataToDisplay {
  private toDos$ = inject(TodoService).getToDos({ limit: 3 });

  loading = true;
  refreshing = false;
  error = false;
  toDos: ToDo[] = [];
  errorData: Error | null = null;

  constructor() {
    this.loadToDos();
  }

  refresh() {
    this.refreshing = true;
    this.loadToDos();
  }

  private loadToDos() {
    this.toDos$.subscribe({
      next: (toDos) => {
        this.loading = false;
        this.refreshing = false;
        this.error = false;
        this.toDos = toDos;
      },
      error: (error) => {
        this.error = true;
        this.loading = false;
        this.refreshing = false;
        this.errorData = error;
      },
    });
  }
}
```

```tsx
if (loading) {
  <p>Spinner</p>;
} else if (error) {
  <p>Something bad happened</p>;
} else {
  <table>...</table>;
  if (refreshing) {
    <p>Inner spinner</p>;
  }
}
```

## State object

To resolve described problems with too many
variables we can create something that is called state object.
This pattern is about creating a plan JavaScript
object and storing all data needed to display the view in a single object.

```ts
export interface ComponentState {
  loading: boolean;
  refreshing: boolean;
  toDos: Item[];
  error: boolean;
  errorData: Error | null;
}

const INITIAL_STATE: ComponentState = {
  loading: true,
  refreshing: false,
  toDos: [],
  error: false,
  errorData: null,
} as const;
```

Now we can come back to our component
and replace all properties with single-state objects.
Thanks to that our component is more readable.

```ts
export class DataToDisplay {
  private toDos$ = inject(TodoService).getToDos({ limit: 3 });

  state = getInitialState();

  constructor() {
    this.loadToDos();
  }

  refresh() {
    this.state.refreshing = true;
    this.loadToDos();
  }

  private loadToDos() {
    this.toDos$.subscribe({
      next: (toDos) => {
        this.state.loading = false;
        this.state.refreshing = false;
        this.state.error = false;
        this.state.toDos = toDos;
      },
      error: (error) => {
        this.state.error = true;
        this.state.loading = false;
        this.state.refreshing = false;
        this.state.errorData = error;
      },
    });
  }
}
```

<Note type='IMPORTANT'>

In this example we mutate a state object to change a property
but if we need we can make our object read-only to
force a developer to create a new state each time we want to change something.

```ts
export interface ComponentState {
  readonly loading: boolean;
  readonly refreshing: boolean;
  // ...
}
```

</Note>

<Demo height={450} repository={frontmatter.repository} path="state-object" branch="main" />

## Problem with types

Imagine a situation where we want to create an effect to log an error message.
When an error occurs we want to get the `errorData` property.

```ts
export function errorCountEffect(state: ComponentState): void {
  if (state.error === true) {
    const type = state.errorData?.message; // I had to add `?` because `errorData` can be null

    // ...
  }
}
```

<Note type='HELPFUL'>

We should not have a situation where `error` is set as `true` but `errorData` is `null`.

```ts
const type = state.errorData!.message;
```

</Note>

<Note type='CRITICAL'>

_TypeScript_ will throw an error _errorData is possibly null_ only when you have `strictNullChecks` or `strict` flag turned on.

</Note>

## Union states

In a situation where we know that `error` and `errorData` properties are connected
(when `error` is `false` then `errorData` is `null` and when `error` is `true` then `errorData` is defined)
we can create interfaces for each state and connect them with [Union types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types).

```ts
export interface NoErrorState {
  loading: boolean;
  refreshing: boolean;
  toDos: ToDo[];
  error: false;
  errorData: null;
}

export interface ErrorState {
  loading: boolean;
  refreshing: boolean;
  toDos: ToDo[];
  error: true;
  errorData: Error;
}

export type ComponentState = NoErrorState | ErrorState;
```

Thanks to that separation, we tell TypeScript that `ComponentState`
is one of two states: `NoErrorState` or `ErrorState`
and TypeScript will know when `error` is `true` then `errorData` is defined.

```ts
export function errorCountEffect(state: ComponentState): void {
  if (state.error === true) {
    const type = state.errorData.message; // There is no error now! No need to add `?`.

    // ...
  }
}
```

<Note type='IMPORTANT'>

TypeScript knows that when `error` is `true` then `state` inside `if` block has type `ErrorState`
([TS Playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCoHsAi7kG9kC+AUERAB4AO6UYyoksiKAcugKJRTUDKYckeIsmHIANujgATUAHMAXMgBG6dKIhwQAbiEioEGHoDOAC1kLlq9Vp3CwWdIYUZsAbQC62kcmhcoC+KKGEJ4iPtSY-HAKIACuoqLaxKSU1LT00PBIyBy+vPwouDZiEtIg8koqahohwnoGECZmFZbVRXbYjmj27jXenNQKYFAxwUVhUBF8CjnUiSTkVDTIYACeFCgAwugAtlQgEOB5AgC8yKwzUEcoAD7Z-Zd8kNrzKUswMSAIYMDoIH2+Ww+YDYMBgEC+AApDI8IAotrtfgcwFcAJQKABu6GAkkERWh+V6AHpCcgAHoAfhIXmAMGQUJhADpxshjqzlsMICjcV4vPinkUvMSyZSBSIEL9ocs1ihTnyIEz7pM4Aztg1DHAZKMvMQCEA)).

</Note>

## Split into more states

When we know that we can create many states and connect
them into a single type we can define all possible states with interfaces.

```ts
interface LoadingState {
  loading: true;
}

interface LoadedState {
  toDos: ToDo[];
}

interface RefreshingState {
  refreshing: true;
  toDos: ToDo[];
}

interface ErrorState {
  error: true;
  errorData: Error;
}

export type ComponentState = LoadingState | LoadedState | RefreshingState | ErrorState;
```

## Checking current state

Lets go back to our effect where we want to check current state.
To do this we have to check which properties are defined and which are not.

```ts
export function errorCountEffect(state: ComponentState): void {
  if ("error" in state) {
    const message = state.errorData.message;
    // ...
  }
}
```

<Note type='CRITICAL'>

This statement is not readable and each time we have to know what to check.

</Note>

<Note type='IMPORTANT'>

Keyword `in` is used as a type guard.
Because only `LoadedState` has `data` property _TypeScript_
knows that inside `if` variable `currentState` have to be `LoadedState`
([TS Playground](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCoHsAi7kG9kC+AUEaJLIigDLpwAmoA5gMphyR5HLfIA2tDEIwBcyMFACuEANxFipcNHhJkNehDqt2KXFx5gs6AM6iM2ANoBdWfLJLKyAEoQYUCEYAWTLR109kbq7uXkKi4lKy-gbYJmiGVjYkdhQqAKJQUOhQPjp63NCZUGGSMnnIBVmY7HCi6YWJRBAAHgAOWWBiAJ4tKADC6AC2bSAQ4DnIALyqAt5sHAA+0+qacyiLzkGes9rIi3VZObKNre3IMBIgCGDA6CDlGVn9F2CpMDAQVwAURqui-UO3UZgHIASlEADd0MA6Jx-D9tJEeAB6JHIAB6AH4ysAYMhPgAiCpQfHIUDIeGQEGcMpw1aI-zcFHorE0ngIW4-Lo9Sbk1YAOiJVTYfIG7iMcEYpQZyNRfLlZWIBCAA)).

</Note>

## Named states

To make easier checking current state we can create a special property which will hold current state name.

```ts
export interface LoadingState {
  state: "LOADING";
}

export interface LoadedState {
  state: "LOADED";
  toDos: ToDo[];
}

export interface RefreshingState {
  state: "REFRESHING";
  toDos: ToDo[];
}

export interface ErrorState {
  state: "ERROR";
  error: Error;
}

export type ComponentState = LoadingState | LoadedState | RefreshingState | ErrorState;
```

<Note type='HELPFUL'>

We can create a interface to share base properties. This is nice to have but not required.

```ts
interface State<T> {
  state: T;
}

export interface LoadedState extends State<"LOADED"> {
  toDos: ToDo[];
}
```

</Note>

Now we can refactor the previous function and use simple checking of `state` property.
